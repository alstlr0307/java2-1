# 김민식 학번 202130104

## 3월 15일 강의
내용정리

## 3월 22일 강의
내용정리

명령어 : 컨트롤 + 쉬프트 + p
--> java pro까지만 검색 
--> java create java project 선택 
--> 파일지정

자바 --> .java파일은 버전이 모두 다르고 사용환경 (ex: 윈도우, 맥, 리눅스 등)
모두 다르기 때문에 윈도우에서 작업한 파일은 맥에서 작동하지 않는다.
따라서 .java파일을 .class 파일로 변환하여 저장하면 모든 플랫폼에서 작업이 가능하다.

이 과정에 필요한 것은 "자바 버추얼 머신( 통칭: JVM )" 이다

개발하는 과정에서 필요한 것은 ( JDK ) 이다
사용하는 입장에서 필요한 것은 ( JRE ) 이다

서블릿은 웹브라우저에서 실행되는 자바스킄립트 코드와 통신

*자바 API
JDK에 포함된 클래스 라이브러리 
주요한 기능들을 미리 구현한 클래스 라이브러리의 집합
API에서 정의한 규격에 따라 글래스 사용
자바 패키지 
서로 관련된 클래스들을 분류하여 묶어 놓은 것
   클래스의 이름에 패키지 이름도 포함
   다른 패키지의 동일한 이름의 클래스 존재 가능
*자바 통합 개발 환경-이클립스

*IDE
 -통합 개발 환경 
 -편집,컴파일,디버깅을 한번에 할 수 있는 통합된 개발 환경

*이클립스
 -자바 응용 프로그램 개발을 위한 통합 개발 환경
 -IBM에 의해 개발된 오픈 소스 프로젝트

*자바 모바일 응용 : 안드로이드 앱


※자바의 특징
 -플랫폼 독립성
 -객체지향-캡슐화,상속,다형성 지원
 -클래스의 캡슐화
 -자바의 모슨 변수나 함수는 클래스 내에 선언
 -클래스 안에서 클래스(내부 클래스) 작성 가능
 -소스(.java) 와 클래스 (.class) 파일
 -하나의 소스 파일에 여러 클래스를 작성 가능 - public 클래스는 하나만 가능
 -소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 함
 -클래스 파일에는 하나의 클래스만 존재- 다수의 클래스를 가진 자바 소스를 컴파일하면 클래스마다 별도 클래스 파일 생성

 *실행코드 배포
  -한개의 class파일 또는 다수의 class파일로 구성
  -여러 폴더에 걸쳐 다수의 클래스 팡일로 구성된 경우 : jar 압축 파일로 배포
  -자바 응용프로그램의 실행은 main() 메소드에서 시작
  -하나의 클레스 파일에 두개 이상의 main() 메소가 있을수 없음.

 *패키지
  -서로 관련 있는 여러 클래스를 패키지로 묶어 관리
  -패키지는 폴더 개념

 *멀티스레드 
  -여러 스레드의 동시 수행 환경 지원
  -자바는 운영체계의 도움 없이 자체적으로 멀티 스레드 지원
  -C/C++프로그램은 멀티스레드를 위해 운영체게 API를 호출

 *가비지 컬랙션
  -자바 언어는 메모리 할당 기능은 있어도 메모리 변환 기능은 없음

 *실시간 응용프로그램에 부적합
  -실행 도중 예측할 수 없는 시점에 가비지 컬랙션 실행 때문
  -응용프로그램의 일시적 중단 발생

 *자바 프로그램은 안전
  -타입 체크 엄격
  -물리적 주소를 사용하는 포인터 개념 없음

 *프로그램 작성 쉬움
  -포인터 개념 없음
  -동적 메모리 반환 하지 않음
  -다양한 라이브러리 지원

 *실행 속도 개선을 위한 JTI 컴파일러 사용
  -자바는 바이트 코드를 인터프라터 방식으로 실행
   -기계어가 실행되는 것보다 느림
  -JIT 컴파일 기법으로 실행 속도 개선
   -JTI 컴파일 - 실행 중에 바이트 코드를 기계어 코드로 컴파일하여 기계어를 실행하는 기법

----------------------------------------------------------------------------------------


[ 식별자 ]
1. 클래스, 변수, 상수, 메소드 등에 붙이는 이름
2. 식별자의 원칙
 <1>특수문자와 공백 또는 탭은 식별자로 사용이 불가능하다
 <2>유니코드 문자 사용가능, 한글도 사용가능
 <3>자바언어의 키워드는 식별자로 사용불가
 <4>식별자의 첫 번째 문자는 숫자로 불가능

[ 자바 데이터 타입 종류 ]
boolean
char
byte
short
int
long
float
double

[ 리터럴과 정수 리터럴 ]
1. 리터럴
    <1>프로그램에서 직접 표현한 값
    <2>정수, 실수, 문자, 논리, 문자열 리터럴이 있음
2. 정수 리터럴
    <1>10진수, 16진수, 8진수 등..

[ 실수 리터럴 ]
1. 소수점 형태나 지수 형태로 표현한 실수
    <1>12, 12.0, 12.00, 12.000
2. 실수 타입 리터럴은 double로 표현

[ 문자 리터럴 ]
1. 단일 인용부호 (**)로 문자 표현
2. 특수문자 리터럴은 백슬래시| ( \ ) 로 표현 함

[ 상수 ]
1. 상수 선언
    <1>final 키워드 사용
    <2>선언 시 초기값 지정
    <3>실행 중 값 변경 불가

[ var 키워드 ]
* JAVA 10 부터 도입됨 *
1. 기존 변수선언 방식 : 변수의 타입 반드시 지정
2. var키워드
    <1>타입을 생략하고 변수 선언 가능
    <2>컴파일러가 추론하여 변수 타입 결정
    <3>변수 선언 시 초기값이 주어지지 않으면 컴파일 오류

[ 타입 변환 ]
1. 한 타입의 값을 다른 타입의 값으로 변환

[ 자동 타입 변환 ]
1. 컴파일러에 의한 월래의 타입보다 큰 타입으로 자동 변환

## 3월 29일 강의

Scanner 클래스
읽은 바이트를 문자,정수,실수,불린,문자열 등으로 변환하여 리턴
java.util.scanner

scanner는 입력되는 키 값을 공백으로 구분되는 토큰단위로 읽음
--> 개발자가 읽기 쉬운 타입 값으로 읽을 수 있음

식과 연산자
연산

산술 연산자  < + , -, *, /, % >
더하기, 빼기, 곱하기, 나누기, 나눈 값 의 나머지<1>주어진 식을 계산하여 결과를 얻어내는 과정

조건 연산자
3개의 피연산자로 구성된 삼항 연산자
if-else을 조건연산자로 간결하게 표현 가능

비트 연산
비트의 개념<1>비트끼리 and, or, xor, not연산

비트 논리 연산<1> 피연산자들의 각 비트들을 대상으로하는 연산

조건무 단순 if문, if-else문

switch 문
스위치문은 식과 케이스 문의 값과 비교
    <1>case의 비교 값과 일치하면 해당 케이스의 실행문장 수행
    --> breack를 만나면 빠져나감

반복문
자바의 반복문 for , while, do-while 문<1> for문은 가장 많이 사용하는 문<2> while문은 조건식이 "참"인 경우 반복 실행

    <3> do-while문은 일정한 조건이 참일 때까지 특정한 작업을 반복 실행

자바 배열
1. 배열(array)
    <1>인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조
        -->배열을 이용하면 한 번에 많은 메모리 공긴 선언 가능
    <2>배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간
        -->원소 데이터들이 순차적으로 저장
        -->인덱스를 이용하여 원소 데이터 접근
        -->반복문을 이용하여 처리하기에 적합한 자료구조
2. 배열 인덱스
    <1>0 부터 시작
    <2>인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대 위치까지

배열 선언 및 생성 디테일
1. 배열 선언과 배열 생성의 두 단계 필요
    <1>배열 선언
        -->배열의 이름 선언
        -->배열 생성
        -->배열 초기화

배열 인덱스와 배열 원소 접근
1. 배열 인덱스
    <1>배열 인덱스는 0 ~ ( 배열의 크기 - 1 )
[ ex: code ]
--> 배열 선언
my_array = [10, 20, 30, 40, 50]

--> 배열의 크기
array_size = len(my_array)

--> 배열의 인덱스와 원소 접근
for i in range(array_size):
    print(f"인덱스 {i}: {my_array[i]}")

--> 마지막 요소에 접근
last_index = array_size - 1
last_element = my_array[last_index]
print(f"마지막 요소의 인덱스 {last_index}: {last_element}")

레퍼런스 치환과 배열 공유
1. 레퍼런스 치환으로 두 레퍼런스가 하나의 배열 공유
[ ex: code ]
let array1 = [1, 2, 3, 4];
let array2 = array1; // 레퍼런스 치환

console.log(array1); // [1, 2, 3, 4]
console.log(array2); // [1, 2, 3, 4]

array1[0] = 5;

console.log(array1); // [5, 2, 3, 4]
console.log(array2); // [5, 2, 3, 4]

배열의 크기, length필드
1. 자바의 배열은 객체로 처리
    <1>배열 객체의 length필드
        -->배열의 크기는 배열 객체의 length 필드에 저장
    <2>length필드를 이용하여 배열의 모든 값을 출력하는 사례
    [ ex : code ]
    public class ArrayExample {
    public static void main(String[] args) {
        // 배열 선언, 생성, 초기화
        int[] numbers = {10, 20, 30, 40, 50};
        
        // 배열의 길이를 이용하여 모든 요소 출력
        System.out.println("배열의 요소:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.println("numbers[" + i + "] = " + numbers[i]);
        }
    }
}

배열과 for-each문
1. for-each문
    <1>주어진 배열 또는 컬렉션의 크기만큼 반복하면서 각 요소에 접근할 수 있습니다.

2차원 배열
1. 2차원 배열은 행과 열로 구성된 배열이며, 각 요소에는 두 개의 인덱스를 사용하여 접근
2. 2차원 배열을 만들 때는 배열 안에 배열을 넣는 방식으로 표현하고, 이를 통해 행과 열의 관계를 표현
3. 2차원 배열을 이용할 때는 이중 반복문을 통해 각 요소에 접근하고 처리


## 4월 5일 강의

자바의 예외 클래스
1. 배열의 범위를 벗어나 원소를 접근하는 예외 처리
<1> 자바에서 배열의 범위를 벗어나 원소를 접근하려고 할 때 발생하는 예외는 ArrayIndexOutOfBoundsException이고, 이 예외는 배열의 유효하지 않은 인덱스에 접근하려고 할 때 발생 배열의 유효한 인덱스 범위는 0부터 배열의 길이 - 1까지이며, 이 범위를 벗어나는 인덱스에 접근하면 이 예외가 발생

[ 세상 모든 것이 객체다..? ]
자바의 객체지향 특성 : 캡슐화
1. 캡슐화 : 객체를 캡술로 써서 내부를 볼 수 없게 하는것
    <1> 객체의 가장 본직적인 특징
    <2> 외부의 접근으로부터 객체 보호

자바의 캡슐화
1. 클래스 : 객체 모양을 선헌한 툴( 캡슐화 하는 틀 )
    --> 클래스 내에 메소드와 필드를 구현함

자바의 객체 지향 특성 : 상속
    <1>상위 개체의 속성이 하위 개체에 물려짐
    <2>하위 개체가 상위 개체의 속성을 모두 가지는 관계

자바_상속
1. 상위 클래스의 맴버를 하위 클래스가 물려받음
    <1>상위 클래스 : 수피 클래스
    <2>하위 클래스 : 서브 클래스, 수피 클래스 코드의 재사용, 새로운 특성 추가 기능

자바의 객체 지향 특성 : 다향성
1. 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
2. 다향성 사례
    <1>메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
    <2>메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현

객체 지향 언어의 목적
1. 소프트웨어의 생산성 향상
    <1>소프트웨어를 빠른 속도로 생산할 필요성 중대
2. 객체 지향 언어
    <1>상속, 다향성, 객체, 캡슐화 등 소프트웨어 재사용시간을 위한 장치 내장
    <2>소프트웨어 재사용과 부분 수정 빠름
    <3>소프트웨어를 다시 만드는 부담 대폭 줄임
    <4>소프트웨어 생산성 향상

3. 초기 프로그래밍
    <1>수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요
4. 현대 프로그래밍
    <1>컴퓨터가 산업 절반에 활용
    <2>실세계에서 발생하는 일을 프로그래밍

5. 객체지향 언어에 대한 총괄 설명 ( from_chatGPT )
클래스(Class): 클래스는 객체를 생성하기 위한 템플릿이며, 객체의 설계도라고 할 수 있습니다. 클래스는 객체의 속성을 정의하는 데이터 필드와 해당 데이터를 다루는 메서드를 포함합니다.

객체(Object): 클래스의 인스턴스로, 메모리에 할당된 실제 데이터입니다. 객체는 데이터와 해당 데이터를 처리하기 위한 메서드를 가지고 있습니다.

상속(Inheritance): 상속은 기존 클래스의 속성과 메서드를 다른 클래스가 재사용할 수 있도록 하는 개념입니다. 부모 클래스(슈퍼 클래스)의 특성을 자식 클래스(서브 클래스)가 상속받아 확장하거나 수정할 수 있습니다.

다형성(Polymorphism): 다형성은 같은 이름의 메서드가 서로 다른 기능을 할 수 있도록 하는 개념입니다. 이는 메서드 오버로딩(Overloading)과 메서드 오버라이딩(Overriding)을 통해 구현될 수 있습니다.

캡슐화(Encapsulation): 캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나의 단위로 묶는 개념입니다. 이를 통해 데이터를 보호하고 외부에서 직접 접근하는 것을 제어할 수 있습니다.

객체지향언어를 사용하면 코드를 모듈화하고 재사용성을 높일 수 있으며, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 또한 실제 세계의 개념을 쉽게 모델링할 수 있어서 문제 해결에 있어서 직관적이고 유연한 설계를 할 수 있습니다. Java, C++, Python, C#, 등 많은 프로그래밍 언어가 객체지향언어의 개념을 지원하고 있습니다.

절차 지향 프로그래밍과 객체 지향 프로그래밍
1. 절차 지향 프로그래밍
    <1>작업 순서를 표현하는 컴퓨터 명령 집합
    <2>함수들의 집합으로 프로그램 작성

2. 객체 지향 프로그래밍
    <1>객체 지향 프로그래밍은 현실 세계의 객체들을 모델링하여 소프트웨어를 개발하는 방법으로, 클래스와 객체를 중심으로 데이터와 기능을 조직화하여 코드를 구성, 이를 통해 코드의 재사용성을 높이고 유지보수를 용이하게 하며, 복잡한 문제를 더 직관적이고 구조화된 방식으로 해결할 수 있다.

클래스와 객체
1. 클래스
    <1>객체의 속성과 행위 선언
    <2>객체의 설계도 혹은 틀

2. 객체
    <1>클래스의 틀로 찍어낸 실체
        -->프로그램 실행 중에 생성되는 실체
        -->메모리 공간을 갖는 구체적인 실체 
        -->인스턴트 라고도 부름
3. 사례 ( EX )
    <1>클래스 : 소나타자동차
    <2>클래스 : 벽시계
    <2>클래스 : 책상

클래스와 객체와의 관계/차이 ( 추가설명 )
1. 클래스는 객체를 생성하기 위한 템플릿이며, 객체의 설계도 역할을 수행, 객체는 클래스의        인스턴스로, 메모리에 할당된 실제 데이터이고, 클래스는 객체를 생성하기 위한 구조를 정의하고, 객체는 클래스를 기반으로 생성되어 실제 작업을 수행

자바 클래스 구성
1. 클래스 이름: 클래스의 이름은 대소문자를 구분하는 식별자로, 클래스를 식별하는 데 사용

2. 속성(멤버 변수): 클래스 내부에는 속성이 포함될 수 있습니다. 이러한 속성들은 클래스의 상태를 나타내며, 멤버 변수로 선언

3. 메서드(멤버 함수): 클래스에는 데이터를 처리하거나 특정 동작을 수행하는 메서드가 포함됩니다. 이러한 메서드들은 클래스의 동작을 정의하고 구현

4. 생성자(Constructor): 생성자는 객체가 생성될 때 호출되는 특수한 종류의 메서드로, 객체의 초기화를 담당

5. 접근 제어 지시자(Access Modifiers): private, protected, public 등의 접근 제어 지시자를 사용하여 클래스의 멤버 변수와 메서드에 대한 접근 권한을 제어할 수 있음

6. 내부 클래스(Inner Class): 클래스 내부에 다른 클래스를 선언하는 것이 가능합니다. 이러한 내부 클래스는 외부 클래스의 멤버에 쉽게 접근할 수 있음

생성자의 특징
1. 생성자 이름은 클래스 이름과 동일
2. 생성자는 여러 개 작성 가능 ( 생성자 중복)
3. 생성자는 객체 생성 시 한 번만 호출
4. 생상자의 목적은 객체 생성 시 초기화
5. 생성자는 리턴 타입을 지정할 수 없음

기본 생성자가 자동 생성되지 않는 경우
1. 클래스에 생성자가 선언되어 있는 경우
    <1>컴파일러는 기본 생성자를 자동 생성해 주지 않는다

this 래퍼런스
1. this
    <1>객체 자신에 대한 레퍼런스
        --> 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
        --> this 맴버 형태로 맴버를 접근할 때 사용
2. this()로 다른 생성자 호출
    <1>this()
        --> 현재 클래스의 다른 생성자 호출: this()는 같은 클래스 내의 다른 생성자를 호출
        --> 생성자 중복 최소화: 생성자들 간의 중복된 초기화를 피하기 위해 사용됩니다.
        --> 초기화 과정 단순화: 공통된 초기화 코드를 간결하게 작성할 수 있습니다.

객체 배열
1. 자바의 객체 배열
    <1>객체에 대한 레퍼런스 배열함
2. 자바의 객체 배열 만들기 3단계
    <1> 여러 객체 저장: 객체 배열은 여러 개의 객체를 저장하는 자료 구조
    <2> 인덱스로 접근: 각 객체는 배열의 인덱스를 통해 접근
    <3> 객체 생성과 관리: 동일한 클래스의 객체를 생성하고 관리하는데 사용

메소드
1. 메소드 설명
    <1>메소드는 c/c++의 함수와 동일
    <2>자바의 모든 메소드는 반드시 클래스 안에 있어야 함 ( 캡슐화 원칙 )

2. 메소드 설정
    <1> 메소드 정의: 클래스 내부에 특정 기능을 수행하는 코드 블록을 포함
    <2> 메소드 호출: 메소드를 실행하기 위해 해당 메소드의 이름과 필요한 매개변수를 전달, 실행
    <3> 메소드 설정: 메소드의 속성을 결정하는 과정으로, 접근 제어자, 반환 유형, 예외 처리 등을 설정, 메소드의 동작을 조정

객체 소멸
1. 객체 소멸 설명
    <1>new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
    <2>소멸된 객체 공간으 ㄴ가용 메모리에 포함
2.자바에서 사용자의 임의로 객체 소멸안됨
    <1>자바는 객체 소멸 연산자 없음
        -->객체 생성 연산자 : new
    <2>객체 소멸은 자바 가상 기계의 고유한 역활
    <3>자바 개발자에게는 매우 다행스러운 기능
        -->c/c++에서 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야함
        -->c/c++의 프로그램 작성을 어렵게 만드는 요인
        -->c/c++에서는 사용하지 않는 객체나 배열을 돌려주는 코딩의 책임을 사용자에게서 하지않음

가비지
1. 가비지 설명
    <1>가리키는 레퍼런스가 하나도 없는 객체
        -->더 이상 접근할 수 없어 사용할 수 없게 된 메모리

2. 가비지 컬랙션
    <1>자바 가상 기계의 컬랙터가 자동으로 가바지 수집, 반환

3. 강제 가비지 컬랙션
1. System 또는 Runtime 객체의 gc() 메소드를 호출
    --> 이 코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청
    --> 그러나 자바 가상 시계가 가비지 컬렉션 시점을 전적으로 판단

자바의 패키지 개념
1. 패키지 설명
    <1>상호 관련 있는 클래스 파일 ( 컴파일된, .class) 을 저장하여 관리는 디렉터리
    <2>자바 응용프로그램은 하나 이상의 패키지로 구성

접근 지정자
1. 자바의 접근 지정자 설명
    <1> 4가지 ( public, protective, defalut, private )
2. 접근 지정자의 목적
    <1>클래스나 일부 맴버를 공개하여, 다른 클래스에서 접근하도록 허용
    <2>객체 지향 언어의 캡술화 정책은 맴버를 보호하는 것
3. 접 근 지정자에 따른 클래스나 맴버의 공개 범위

클래스의 접근 지정
1. 클래스 접근지정 설명
    <1>다른 클래에서 사용하도록 허용할지 지정
    <2>public 클래스
        --> 다른 모든 클래스에게 접근 허용
    <3>디폴트 클래스 ( 접근지정자 생략 )
        -->package ----- private라고 함

맴버 접근 지정
1. public
    --> 어떤 클래스의 인스턴스든 해당 멤버에 접근할 수 있도록 함. 다른 패키지에서도 접근이 가능
2. protective
    --> 동일한 패키지에 있는 클래스와 해당 클래스를 상속받은 클래스에서만 해당 멤버에 접근
3. default
    --> 동일한 패키지 내의 클래스에서만 해당 멤버에 접근
4. private
    --> 해당 멤버에 접근할 수 있는 범위를 해당 클래스 내부로 제한, 다른 클래스에서는 해당 멤버에 직접 접근이 불가

static 맴버
1. static맴버 선언
2. 객체 생성과 non-static 맴버의 생성
    --> non-static 맴버는 객체가 생설될 때, 객체마다 생긴다

static 맴버 사용
1. 클래스 이름으로 접근이 가능
2. 객체의 맴버로 접근이 가느
3. non-static 맴버는 클래스 이름으로 접근 안됨


## 4월 12일 강의

Static 맴버와 non-Static 맴버 특성 정리

Static 맴버의 생성
1. static맴버는 클래스당 하나만 생성
2. 객체들에 의해 공유됨

[ 5주차 강의 내용 참고 ]-----------------------------------------
static 맴버
1. static맴버 선언
2. 객체 생성과 non-static 맴버의 생성
    --> non-static 맴버는 객체가 생설될 때, 객체마다 생긴다

static 맴버 사용
1. 클래스 이름으로 접근이 가능
2. 객체의 맴버로 접근이 가느
3. non-static 맴버는 클래스 이름으로 접근 안됨
----------------------------------------------------------------

static 메소드의 제약 조건 1
1. tatic 메소드는 오직 static 맴버만 접근 가능
    <1>객체가 생성되지 않은 상황에서도 static메소드는 실행될 수 있기 때문에 non-static 멤버 활용불가
    <2>non-static 메소드는 static맴버 사용 가능

static 메소드의 제약 조건 2
1. static 메소드는 this 사용불가
    <1>static 메소드는 객체 없이도 사용 가능하므로, this 레퍼런스 사용할 수 없음

final 클래스와 메소드
1. final 클래스 -> 더 이상 클래스 상속 불가능
2. final 메소드 -> 더 이상 오버라이딩 불가능

final 필드
1. final필드, 상수 선언
    <1>상수를 선언할 때 사용
    <2>상수 필드는 선선 시에 초기 값을 지정하여아 한다
    <3>상수 필드는 생성중에 필드 값을 초기화 할 수 없다

상속 ( Inheritance )
1. 상속의 선언
    <1>extends 키워드로 선언
        --> 부모 클래스를 물려받아 확장한다는 의미
    <2>부모 클래스 --> 슈퍼 클래스 ( super class )
    <3>자식 클래스 --> 서브 클래스 ( sub class )

서브 클래스 객체의 모양
1. 슈퍼 클래스는 객체와 서브 클래스의 객체는 별개
2. 서브 클래스 객체는 슈퍼 클래스 맴버 포함

자바 상속의 특징
1. 클래스 다중 상속 불허
    <1> c++는 다중상속 클래스가 가능

슈퍼 클래스의 맴버에 대한 서브 클래스의 접근
1. 슈퍼 클래스의 private 맴버
    <1>서브 클래스에서 접근할 수 없음

2. 슈퍼 클래스의 디폴트 맴버
    <1>서브 클래스가 동일한 패키지에 있을 때, 접근 가능

3. 슈퍼 클래스의 public맴버
    <1>서브 클래스는 항상 접근 가능

4. 슈퍼 클래스의 protected 상속

protected 맴버
1. protected 맴버에 대한 접근 
    <1>같은 패키지의 모든 클래스에 접근 허용
    <2>상속되는 서브 클래스에게 허용

서브 클래스와 슈퍼 클래스의 생성자 선택 
1. 슈퍼 클래스와 서브클래스
    <1>각각 여러개의 생성자 작성가능

서브 클래스의 객체가 생성될 때
1. 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행

서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정된는 방식
1. 개발자의 명시적 선택

[ 업캐스팅과 다운캐스팅 설명?? ]

업캐스팅의 개념
1. 업캐스팅은 하위 클래스를 상위 클래스 타입으로 변환하는 것. 상속 계층 구조에서 자주 사용되며, 다형성을 활용하여 다양한 객체를 동일한 인터페이스로 다룰 수 있게 컴파일 타임 다형성을 제공하여 유연하고 확장 가능한 코드를 작성하는 데 도움이 됨

업캐스팅
1. 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
2. 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가르키게 되는 현상

다운캐스팅의 개념
1. 다운캐스팅은 상위 클래스 타입을 하위 클래스 타입으로 변환하는 것. 업캐스팅과 반대되며 명시적인 형 변환을 필요로, 주로 상위 클래스로 선언된 객체를 실제로는 하위 클래스로 사용해야 할 때 사용되며 타입 안전성을 보장하기 위해 주의해서 사용해야 함

다운캐스팅
1. 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
2. 업캐스팅된 것을 다시 월래대로 되돌리는 것
3. 반드시 명시적 타입 변환 지정

[ 업캐스팅 레퍼런스로 객체 구별?? ]
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
    --> 슈퍼 클래스에서 여러 서브 클래스에 상속되기 때문.


Instanceof 연산자 사용
1. 레퍼런스가 가르키는 객체의 타입 식별

instanceof 연산자의 활용예제 ( by.코드 )
[ ex.code ]-----------------------------------------------------
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        System.out.println(myDog instanceof Animal); // true
        System.out.println(myDog instanceof Dog);    // true
        System.out.println(myDog instanceof Cat);    // false

        System.out.println(myCat instanceof Animal); // true
        System.out.println(myCat instanceof Dog);    // false
        System.out.println(myCat instanceof Cat);    // true
    }
}

설명: 이 예제는 instanceof 연산자를 사용하여 각 객체가 Animal 클래스, Dog 클래스 또는 Cat 클래스의 인스턴스인지를 확인한다.
[ ex.code ]------------------------------------------------------

메소드 오버라이딩의 개념
1. 메소드 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 덮어쓰는 것, 이를 통해 하위 클래스는 상위 클래스의 동작을 재정의할 수 있다. 이 개념은 다형성을 지원하며, 런타임 시에 객체의 실제 타입에 따라 적절한 메소드가 호출이 됨

오버라이딩의 목적, 다향성 실현
1. 오버라이딩 + 다향성
    <1>하나의 인터페이스에 서로 다른 구현
    <2>슈퍼 클래스의 메소드를 서브 클래세어서 각각 목적에 맞게 다르게 구현
    <3>사례
